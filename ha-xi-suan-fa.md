# 哈希算法

#### Hash

Hash一般翻译做"散列" , 也有直接音译为"哈希"的 , 就是把任意长度的输入\(又叫做预映射 , pre-image\) , 通过散列算法 , 变换成固定长度的输出 , 该输出就是散列值 .

这种转换是一种压缩映射 , 也就是散列值的空间通常远小于输入的空间 , 不同的输入可能会散列成相同的输出 , 所以不可能从散列值来唯一的确定输入值 . 简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数 .

#### 基本概念

若关键字为**k , **则其值存放在**f\(k\)**的存储位置上 . 由此 , 不需比较便可直接取得所查记录 . 称这个对应关系**f**为**散列函数** , 按这个思想建立的表为**散列表** .

对不同的关键字可能得到同一散列地址 , 即**k1≠k2** , 而**f\(k1\)=f\(k2\)** , 这种现象称为**碰撞\(Collision\)** . 具有相同函数值的关键字对该散列函数来说称做同义词 . 综上所述 , 根据散列函数**f\(k\)**和处理碰撞的方法将一组关键字映射到一个有限的连续的地址集\(区间\)上 , 并以关键字在地址集中的“像”作为记录在表中的存储位置 , 这种表便称为**散列表** , 这一映射过程称为**散列造表**或**散列** , 所得的存储位置称**散列地址** .

**散列表**\(Hash table , 也叫哈希表\) , 是根据**关键码值**\(Key value\)而直接进行访问的数据结构 . 也就是说 , 它通过把关键码值映射到表中一个位置来访问记录 , 以加快查找的速度 . 这个映射函数叫做**散列函数** , 存放记录的数组叫做**散列表** . 

给定表M , 存在函数f\(key\) , 对任意给定的关键字值key , 代入函数后若能得到包含该关键字的记录在表中的地址 , 则称表M为哈希\(Hash\)表 , 函数f\(key\)为哈希\(Hash\) 函数 . 

若对于关键字集合中的任一个关键字 , 经散列函数映象到地址集合中任何一个地址的概率是相等的 , 则称此类散列函数为**均匀散列函数**\(Uniform Hash function\) , 这就是使关键字经过散列函数得到一个“随机的地址” , 从而减少碰撞 . 

**举个例子**

> 比如这里有一万首歌，给你一首新的歌X，要求你确认这首歌是否在那一万首歌之内。
>
> 无疑，将一万首歌一个一个比对非常慢。但如果存在一种方式，能将一万首歌的每首数据浓缩到一个数字（称为哈希码）中，于是得到一万个数字，那么用同样的算法计算新的歌X的编码，看看歌X的编码是否在之前那一万个数字中，就能知道歌X是否在那一万首歌中。
>
> 作为例子，如果要你组织那一万首歌，一个简单的哈希算法就是让歌曲所占硬盘的字节数作为哈希码。这样的话，你可以让一万首歌“按照大小排序”，然后遇到一首新的歌，只要看看新的歌的字节数是否和已有的一万首歌中的某一首的字节数相同，就知道新的歌是否在那一万首歌之内了。
>
> 当然这个简单的哈希算法很容易出现两者同样大小的歌曲，这就是发送了碰撞。而好的哈希算法发生碰撞的几率非常小。



参考 :

[https://baike.baidu.com/item/Hash/390310](https://baike.baidu.com/item/Hash/390310)

https://baike.baidu.com/item/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0/9796422

https://www.zhihu.com/question/20820286

