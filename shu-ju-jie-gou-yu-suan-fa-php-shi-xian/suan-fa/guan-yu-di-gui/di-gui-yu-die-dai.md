# 递归与迭代

#### 迭代

迭代算法是用计算机解决问题的一种基本方法 . 它利用计算机运算速度快、适合做重复性操作的特点 , 让计算机对一组指令\(或一定步骤\)进行重复执行 , 在每次执行这组指令\(或这些步骤\)时 , 都从变量的原值推出它的一个新值 .

利用迭代算法解决问题 , 需要做好以下三个方面的工作 :

1. 确定迭代变量 . 在可以用迭代算法解决的问题中 , 至少存在一个直接或间接地不断由旧值递推出新值的变量 , 这个变量就是迭代变量 . 
2. 建立迭代关系式 . 所谓迭代关系式 , 指如何从变量的前一个值推出其下一个值的公式\(或关系\) . 迭代关系式的建立是解决迭代问题的关键 , 通常可以使用递推或倒推的方法来完成 . 
3. 对迭代过程进行控制 . 在什么时候结束迭代过程 ? 这是编写迭代程序必须考虑的问题 . 不能让迭代过程无休止地重复执行下去 .  
   迭代过程的控制通常可分为两种情况 :  
   1. 一种是所需的迭代次数是个确定的值 , 可以计算出来 ;  
   2. 另一种是所需的迭代次数无法确定 .

   对于前一种情况 , 可以构建一个固定次数的循环来实现对迭代过程的控制 . 对于后一种情况 , 需要进一步分析出用来结束迭代过程的条件 .

可以用迭代的算法有很经典的问题 , 比如兔子产子问题 :

> 假定你有一雄一雌一对刚出生的兔子 , 它们在长到一个月大小时开始交配 , 在第二月结束时 , 雌兔子产下另一对兔子 , 过了一个月后它们也开始繁殖 , 如此这般持续下去 . 每只雌兔在开始繁殖时每月都产下一对兔子 , 假定没有兔子死亡 , 在一年后总共会有多少对兔子 ?
>
> 还有上楼梯的走法问题 : 有一段楼梯有10级台阶 , 规定每一步只能跨一级或两级 , 要登上第10级台阶有几种不同的走法 ?

#### 循环和迭代是一回事吗 ?

**loop , iterate , traversal , recursion**

这几个词是计算机技术书中经常会出现的几个词汇 . 分别翻译为 , 循环 , 迭代 , 遍历 , 递归 . 乍一看 , 这几个词好像都与重复\(repeat\)有关 , 但有的又好像不完全是重复的意思 . 看一下解释 :

* 循环\(loop\) : 指的是在满足条件的情况下 , 重复执行同一段代码 . 比如 , while语句 . 
* 迭代\(iterate\) : 指的是按照某种顺序逐个访问列表中的每一项 . 比如 , for语句 . 
* 遍历\(traversal\) : 指的是按照一定的规则访问树形结构中的每个节点 , 而且每个节点都只访问一次 . 
* 递归\(recursion\) : 指的是一个函数不断调用自身的行为 . 比如 , 以编程方式输出著名的斐波那契数列 . 

##### 迭代与循环

循环 : 不变的重复 .

```php
for($i=0; $i < 8; $i++){
    echo 'Hello World~';
}
```

迭代 : "迭" , 轮流 , 轮番 , 替换 , 交替 , 更换 . "代" : 代替 . 所以迭代的意思是 , 变化的循环 , 这种变化就是轮番代替 , 轮流代替 .

```php
$sum = 0;

for($i = 1; $i <= 1000; $i++ ){
    $sum = $sum + i;
}
```

迭代可以理解为循环的一种 . 循环体代码分为固定循环体 , 和变化的循环体 . 迭代减少了冗余代码 , 提高了代码的利用率和动态性 .

#### 递归与迭代

**递归算法与迭代算法**的设计思路区别在于 : 函数或算法是否具备收敛性 , 当且仅当一个算法存在预期的收敛效果时 , 采用递归算法才是可行的 , 否则 , 就不能使用递归算法 .

当然 , 从理论上说 , 所有的递归函数都可以转换为迭代函数 , 反之亦然 . 然而代价通常都是比较高的 . 但从算法结构来说 , 递归声明的结构并不总能够转换为迭代结构 , 原因在于结构的引申本身属于递归的概念 , 用迭代的方法在设计初期根本无法实现 , 这就像动多态的东西并不总是可以用静多态的方法实现一样 . 这也是为什么在结构设计时 , 通常采用递归的方式而不是采用迭代的方式的原因 , 一个极典型的例子类似于链表 , 使用递归定义及其简单 , 但对于内存定义\(数组方式\)其定义及调用处理说明就变得很晦涩 , 尤其是在遇到环链、图、网格等问题时 , 使用迭代方式从描述到实现上都变得很不现实 .

**递归**其实是方便了编程者难为了机器 . 它只要得到数学公式就能很方便的写出程序 . 优点就是易理解 , 容易编程 . 但递归是用栈机制实现的 , 每深入一层 , 都要占去一块栈数据区域 , 对嵌套层数深的一些算法 , 递归会力不从心 , 空间上会以内存崩溃而告终 , 而且递归也带来了大量的函数调用 , 这也有许多额外的时间开销 . 所以在深度大时 , 它的时空性就不好了 .

**迭代**其缺点就是不容易理解 , 编写复杂问题时困难 . 优点是效率高 . 运行时间只因循环次数增加而增加 , 没什么额外开销 . 空间上没有什么增加 .

**迭代**的局部变量占用的内存是一次性的 , 也就是**O\(1\)的空间复杂度** , 而对于递归\(不考虑尾递归优化的情况\) , 每次函数调用都要压栈 , 那么**空间复杂度是O\(n\)** , 和递归次数呈线性关系 .

**递归程序改用迭代实现**的话 , 一般都是要自己维护一个栈的 , 以便状态的回溯 . 如果某个递归程序改用循环的时候根本就不需要维护栈 , 那其实这个递归程序这样写只是意义明显一些 , 不一定要写成递归形式 . 但很多递归程序就是为了利用函数自身在系统栈上的auto变量记录状态 , 以便回溯 .

#### 怎么将递归代码改写为非递归代码 ?

前面很大篇幅提及递归的利弊 , 利是递归代码的表达力强 , 写起来非常简洁 ; 而弊就是空间复杂度搞 , 有堆栈溢出的奉献 , 存在重复计算 , 过多的函数调用会耗时较多等问题 .

前面已经提到 , 递归本身是借助栈来实现的 , 只不过使用的是系统或虚拟机本身提供的栈 , 我们没有感知 . 如果我们自己在内存堆上实现栈 , 手动模拟入栈 , 出栈过程 , 任何递归代码都可以改写成看上去不是递归代码的样子 . 当然 , 这也没啥意义 .

```
f(x) = f(x-1) + 1
```

```php
function f($x)
{
    $ret = 1;
    for ($i = 2; $i <= $x; ++$i) {
        $ret = $ret + 1;
    }
    return $ret;
}

function f2($x)
{
    if ($x == 1) {
        return $x;
    }
    return f2($x - 1) + 1;
}
```

上台阶问题

```php
function fib($n)
{
    if ($n == 1 or $n == 2) {
        return $n;
    }

    return fib($n - 1) + fib($n - 2);
}

$arr = [];        
function fib2($n)
{
    global $arr;
    if ($n == 1 or $n == 2) {
        return $n;
    }

    if (array_key_exists($n, $arr)) {
        return $arr[$n];
    }

    $ret = fib2($n - 1) + fib2($n - 2);
    $arr[$n] = $ret;

    return $ret;
}

function fib2($n)
{
    if ($n == 1 or $n == 2) {
        return $n;
    }

    $ret = 0;
    $pre = 2;
    $prepre = 1;
    for ($i = 3; $i <= $n; $i++) {
        $ret = $pre + $prepre;
        $prepre = $pre;
        $pre = $ret;
    }

    return $ret;
}
```



