# 算法 - PHP实现

**算法**\(algorithms\) - 是针对特定的问题 , 经过精心设计的用来一步步解决该问题从而得到答案的过程 .

直观简单的例子 , 把大象装冰箱的过程 , 就是一个简答算法 . 更真实的例子 , 100条有序的记录 , 普通的算法是从头一条一条的比对 , 直到找到为止 , 用二分查找 , 找7次就找到了 .

算法和数据结构的关系 , 可以抽象的理解为米与巧妇的关系 .

#### 算法具有五个基本特性

输入、输出、有穷性、确定性和可行性 .

**输入输出 - **算法允许具有零个或多个输入,但是必须至少有一个或多个输出 .

**有穷性** - 有穷性是指算法在执行有限的步骤之后 , 可以自动结束而不会出现无限循环 , 并且每一个步骤的执行时间都在可接受的范围内

**确定性** - 算法的每一步骤都具有确定的含义 , 不会出现二义性 .

**可行性** - 再现有的条件下算法的每一个步骤都应该是可以实现的 .

#### 算法设计和实现的原则

正确性、健壮性、高效性、环保性和可读性！

---

> 如何判断我们的算法效率高?
>
> 什么是时间复杂度?如何计算时间复杂度?
>
> 二分法的时间复杂度是多少?暴力破解不重复的6位密码时间复杂度是多少?

* 算法分析方法论
* 算法的时间复杂度
* 常见的时间复杂度类型
* 时间复杂度知识扩展
* 算法的空间复杂度

#### 算法分析方法论

##### 事后统计方案

##### 事前评估方案

方法论就是 - 时间复杂度和空间复杂度 .

### 算法的时间复杂度

算法的时间复杂度实际上就是算法的运行花费的时间 .

固定的公式来**表示时间复杂度** :

```
T(n) = O(f(n))
```

其中`n`表示的是数据规模 , `f(n)`是算法执行的总时间 . 计算时间复杂度 :

```
f(n) = 算法执行语句的数量 * t
```

即算法中语句的执行数量与单条语句执行时间`t`的积 . 所以这样看更明显 :

```
T(n) = O(算法运行总时间)
```

这种 , 把算法运行总时间放在了一个固定的格式中的表示方式叫大O表示法 , 表示最坏复杂度 , 也就是最差也就这样了 . 对应的还有最好的大Ω表示法和平均的大Θ表示法 .

#### 时间复杂度计算实例

```
计算 1+2+3+4+5.....+n 的和！
```

**第一种方式**

生成一个长度为n的数组 , 然后把数据存储到数组中 , 再计算数组各项的和 :

```php
<?php

function sum($n)
{
    $result = 0; # {1}
    $array = range(1, $n); # {2}

    for ($i=0; $i < $n; $i++) { # {3}
    $result += $array[$i]; # {4}
    }

    return $result; # {5}
}
```

计算时间复杂度的流程 , 先看函数体内代码运行过程中执行的次数 . 其中注释的1,2,5都仅执行了一次 , 而3,4步骤执行次数为n . 转换为公式即 :

```
N = 2*n+3 # 计算结构就是算法执行语句的数量
```

套入算法总运行时间公式就是 :

```
f(n) = N * t = (2*n + 3) * t
```

最后表示为时间复杂度 , 即 :

```
T(n) = O((2*n + 3) * t)
```

继续简化 , 这里的t代表的是每一条语句的运行时间 , 因为他们是相同的 , 是一个常数不影响分析结果 :

```
T(n) = O(2*n + 3)
```

用常数1取代运行时间中的所有加法常数 :

```
T(n) = O(2*n + 1)
```

如果最高阶项存在且不是1 , 则去除与这个项相乘的常数 :

```
T(n) = O( n + 1 )
```

如果存在数据规模n , 去掉加法常数项 :

```
T(n) = O(n)
```

**第二种方式**

这里简单修改一下上面的函数 , 不生成数组 , 直接循环计算 :

```php
<?php

function sum($n)
{
    $result = 0;

    for ($i=1; $i <= $n; $i++) {
        $result += $i;
    }

    return $result;
}
```

通过前面的计算 , 最后得到的算法时间复杂度是相同的 . 可以理解为时间复杂度描述的实际上是一种“级别” , 就像手机一样 , 有千元机和旗舰机等 . **同一算法时间复杂度级别中的算法的效率不会差异非常大 .**

**第三种方式**

```
利用高斯公式:f(n) = (1+n)*n/2
```

```php
<?php

function sum($n){
    $result = 0;                               
    $result = (1 + $n) * $n / 2;                 

    return $result;                            
}
```

可以直接看出这里的N=3 , 通过计算 , 时间复杂度为 :

```
T(n) = O(1)
```

这是时间复杂度级别是最好的级别 , 随着数据规模的增加 , O\(n\)级别的算法和O\(1\)级别的算法的差距越来越大 , 说明了时间复杂度描述的是算法动态渐变的状态 .

#### 常见的时间复杂度

```
O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)
```

#### 时间复杂度知识扩展

上面谈到的时间复杂度是指“最坏时间复杂度” , 也是我们通常说的默认的情况 . 与之相对的**最好时间复杂度** , 但实际意义并不大 , 除非我们要求一个算法只要最好的状态能满足需求就可以使用 . 还有**平均时间复杂度** , 它描述了一个算法在处理数据过程中单个数据元素花费的平均时间 . 但问题就是并不好测量 . 所以这种表示方法很难通过直接评估得到结果 . 这个更加接近事后统计的一种方案 .

---

### 算法的空间复杂度

#### 空间复杂度的表示

算法的空间复杂度实际上描述的就是算法程序运行时占用的内存大小 . 记作 :

```
S(n)=O(f(n))

# 其中n指的是数据规模
```

设计算法的原则中“环保性”针对的就是算法的空间复杂度 , 现在空间复杂度往往会忽略 , 因为硬件够便宜了 , 但是存在即有意义 .

时间复杂度低了那么可能就要牺牲掉空间复杂度 . 要降低空间复杂度 , 可能就要牺牲算法的时间复杂度 .

一个简单的for循环的例子 :

```
//代码片段1

$arr = [1,2,3,4,5];

for( $i=0; $i < count( $arr ); $i ++ ){
    echo $arr[ $i ];
}

//代码片段2

$arr = [1,2,3,4,5];
$len = count( $arr );

for( $i=0; $i < $len; $i ++ ){
    echo $arr[ $i ];
}
```

#### 空间复杂度的计算

实际为计算算法占用内存的大小 , 我们需要知道算法中有多少变量 , 每种变量对应了多少内存空间 . 即PHP的每种数据类型占用的实际内存的大小 .

> 由于内存空间会受到所在机器及计算机系统影响 , 这里假设是在64位下的linux系统环境下的数据

**例子1**

```
function arrIterator( $arr ){                   {1}

    for( $i=0; $i < count( $arr ); $i ++ ){     {2}
        echo $arr[ $i ];                        {3}
    }
}
```

第一步：统计算法中变量的个数，类型和对应的内存数量:

```
分析代码可知，其中用到的变量如下：
    $arr    数组    存储有n个整型元素  
    $i      整型
```

第二步：计算算法总内存空间f\(n\):

```
f(n) = n * 8 + 8 = 8*n + 8
```

第三步：计算时间复杂度T\(n\):

```
S(n) = O( f(n) ) = O( 8*n + 8 )

即

S(n) = O( 8*n + 8 )
```

第四步：简化。

```
简化方法和时间复杂度相同:

S(n) = O(n)
```

**例子2**

```
function arrIterator( $arr ){                   {1}

    $len = count( $arr );                       {2}

    for( $i=0; $i < $len; $i ++ ){              {3}
        echo $arr[ $i ];                        {4}
    }

}
```

第一步：统计算法中变量的个数，类型和对应的内存数量:

```
分析代码可知，其中用到的变量如下：
    $arr    数组    存储有n个整型元素
    $len    整型
    $i      整型
```

第二步：计算算法总内存空间f\(n\):

```
f(n) = n * 8 + 8 + 8 = 8*n + 16
```

第三步：计算时间复杂度T\(n\):

```
S(n) = O( f(n) ) = O( 8*n + 16 )

即

S(n) = O( 8*n + 16 )
```

第四步：简化。

```
S(n) = O(n)
```

通过比较两种实现方式的空间复杂度都是O\(n\)级别的，但是第二种方案使用了代码片段二优化之后反而空间复杂度比使用第一个代码片段增加了整型数据的大小，但是我们公认为第二种更快了！而其中原因就是用空间换取了时间！

> 其实算法的空间复杂度计算结果你会发现对应数据类型的空间大小都被简化没了，变成了数一数算法中变量个数的游戏！



