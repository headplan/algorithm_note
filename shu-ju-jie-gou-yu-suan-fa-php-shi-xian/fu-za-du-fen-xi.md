# 复杂度分析

**算法**\(algorithms\) - 是针对特定的问题 , 经过精心设计的用来一步步解决该问题从而得到答案的过程 .

直观简单的例子 , 把大象装冰箱的过程 , 就是一个简答算法 . 更真实的例子 , 100条有序的记录 , 普通的算法是从头一条一条的比对 , 直到找到为止 , 用二分查找 , 找7次就找到了 .

算法和数据结构的关系 , 可以抽象的理解为米与巧妇的关系 .

#### 算法具有五个基本特性

输入、输出、有穷性、确定性和可行性 .

**输入输出 - **算法允许具有零个或多个输入,但是必须至少有一个或多个输出 .

**有穷性** - 有穷性是指算法在执行有限的步骤之后 , 可以自动结束而不会出现无限循环 , 并且每一个步骤的执行时间都在可接受的范围内

**确定性** - 算法的每一步骤都具有确定的含义 , 不会出现二义性 .

**可行性** - 再现有的条件下算法的每一个步骤都应该是可以实现的 .

#### 算法设计和实现的原则

正确性、健壮性、高效性、环保性和可读性！

---

如何判断我们的算法效率高?

> 什么是时间复杂度?如何计算时间复杂度?
>
> 二分法的时间复杂度是多少?暴力破解不重复的6位密码时间复杂度是多少?

* 算法分析方法论
* 算法的时间复杂度
* 常见的时间复杂度类型
* 时间复杂度知识扩展
* 算法的空间复杂度

#### 算法分析方法论

##### 事后统计方案

为什么需要时间复杂度 ? 通常 , 通过统计 , 监控 , 就能得到算法执行的时间和占用的内存大小 . 为什么还需要做时间 , 空间复杂度的分析呢 ? 虽然这种评估算法执行效率的方法是正确的 , 也叫做事后统计法 . 但是 , 这种统计方法有非常大的局限性 .

1.测试结果非常依赖测试环境

测试环境中硬件的不同会对测试结果有很大的影响 . 比如在不同的处理器上 , 代码的执行的效率就是不同的 .

2.测试结果受数据规模的影响很大

比如同一个排序算法 , 测试数据的规模直接影响算法的性能 . 对于小规模的数据排序 , 插入排序可能反倒会比快速排序要快 .

所以 , 我们需要一个不用具体的测试数据来测试 , 就可以粗略的估计算法的执行效率的方法 . 可以称之为事前评估方案 .

##### 事前评估方案

方法论就是 - 时间复杂度和空间复杂度 .

---

### 算法的时间复杂度

算法的时间复杂度实际上就是算法的运行花费的时间 . 但是并不代表代码真正的执行时间 , 而是表示**代码执行时间随数据规模增长的变化趋势** , 所以也叫渐进时间复杂度 , 简称时间复杂度 .

所有代码的执行时间T\(n\)与每行代码的执行次数n成正比 ,

用固定的公式来**表示时间复杂度** :

```
T(n) = O(f(n))
```

其中`n`表示的是数据规模 , `f(n)`是算法执行的总时间 . 计算时间复杂度 :

```
f(n) = 算法执行语句的数量 * t
```

即算法中语句的执行数量与单条语句执行时间`t`的积 . 所以这样看更明显 :

```
T(n) = O(算法运行总时间)
```

这种 , 把算法运行总时间放在了一个固定的格式中的表示方式叫大O表示法 , 表示**最坏复杂度** , 也就是最差也就这样了 . 对应的还有**最好的大Ω表示法**和**平均的大Θ表示法** .

> 公式中的低阶 , 常量 , 系数三部分并不左右增长趋势 , 所以都可以忽略 .

#### 时间复杂度计算实例

```
计算 1+2+3+4+5.....+n 的和！
```

**第一种方式**

生成一个长度为n的数组 , 然后把数据存储到数组中 , 再计算数组各项的和 :

```php
<?php

function sum($n)
{
    $result = 0; # {1}
    $array = range(1, $n); # {2}

    for ($i=0; $i < $n; $i++) { # {3}
    $result += $array[$i]; # {4}
    }

    return $result; # {5}
}
```

计算时间复杂度的流程 , 先看函数体内代码运行过程中执行的次数 . 其中注释的1,2,5都仅执行了一次 , 而3,4步骤执行次数为n . 转换为公式即 :

```
N = 2*n+3 # 计算结构就是算法执行语句的数量
```

套入算法总运行时间公式就是 :

```
f(n) = N * t = (2*n + 3) * t
```

最后表示为时间复杂度 , 即 :

```
T(n) = O((2*n + 3) * t)
```

继续简化 , 这里的t代表的是每一条语句的运行时间 , 因为他们是相同的 , 是一个常数不影响分析结果 :

```
T(n) = O(2*n + 3)
```

用常数1取代运行时间中的所有加法常数 :

```
T(n) = O(2*n + 1)
```

如果最高阶项存在且不是1 , 则去除与这个项相乘的常数 :

```
T(n) = O( n + 1 )
```

如果存在数据规模n , 去掉加法常数项 :

```
T(n) = O(n)
```

**第二种方式**

这里简单修改一下上面的函数 , 不生成数组 , 直接循环计算 :

```php
<?php

function sum($n)
{
    $result = 0;

    for ($i=1; $i <= $n; $i++) {
        $result += $i;
    }

    return $result;
}
```

通过前面的计算 , 最后得到的算法时间复杂度是相同的 . 可以理解为时间复杂度描述的实际上是一种“级别” , 就像手机一样 , 有千元机和旗舰机等 . **同一算法时间复杂度级别中的算法的效率不会差异非常大 .**

**第三种方式**

```
利用高斯公式:f(n) = (1+n)*n/2
```

```php
<?php

function sum($n){
    $result = 0;                               
    $result = (1 + $n) * $n / 2;                 

    return $result;                            
}
```

可以直接看出这里的N=3 , 通过计算 , 时间复杂度为 :

```
T(n) = O(1)
```

这是时间复杂度级别是最好的级别 , 随着数据规模的增加 , O\(n\)级别的算法和O\(1\)级别的算法的差距越来越大 , 说明了时间复杂度描述的是算法动态渐变的状态 .

**只关注循环执行次数最多的一段代码**

在分析一个算法 , 一段代码的时间复杂度的时候 , 也只关注循环执行次数最多的那一段代码就可以了 , 这段核心代码执行次数的n的量级 , 就是整段要分析代码的时间复杂度 . 

**加法法则 : 总复杂度等于量级最大的那段代码的复杂度**

**乘法法则 : 嵌套代码的复杂度等于嵌套内外代码复杂度的乘积**

#### 常见的时间复杂度

```
O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)
```

#### 时间复杂度知识扩展

上面谈到的时间复杂度是指“最坏时间复杂度” , 也是我们通常说的默认的情况 . 与之相对的**最好时间复杂度** , 但实际意义并不大 , 除非我们要求一个算法只要最好的状态能满足需求就可以使用 . 还有**平均时间复杂度** , 它描述了一个算法在处理数据过程中单个数据元素花费的平均时间 . 但问题就是并不好测量 . 所以这种表示方法很难通过直接评估得到结果 . 这个更加接近事后统计的一种方案 .

