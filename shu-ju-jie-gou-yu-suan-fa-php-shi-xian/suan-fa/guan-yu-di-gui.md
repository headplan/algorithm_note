# 关于递归

推荐注册返佣金的这个功能应该不陌生 . 现在很多App都有这个功能 . 用户A推荐用户B来注册 , 用户B又推荐用户C来注册 . 用户C的最终推荐人是用户A , 用户B的最终推荐人也是用户A , 用户A没有最终推荐人 .

通常会通过数据库来记录这种推荐关系 . 在数据库表中 , 记录两行数据 , 其中actor\_id表示用户id , referrer\_id表示推荐人id .

![](/assets/tuijianguanxi.png)

给定一个用户ID , 如何查找这个用户的最终推荐人 , 就是下面要学习的内容 , 递归\(Recursion\) .

#### 如何理解递归

递归是一种应用非常广泛的算法 , 或者说是编程技巧 . 很多数据结构和算法的编码实现都要用到递归 , 比如DFS深度优先搜索 , 前中后序二叉树遍历等等 .

> 一个生活中的例子 . 在电影院中 , 你不知道自己是第几排 , 于是就问前面的人他是第几排 , 只要是前面的人的排数加一就知道了 , 如果前面的人也不知道自己是第几排 , 就问他前面的人 , 直到第一排 , 然后第一排的人说我是第一排啊 , 再告诉后面的人 , 一排一排的传回来 , 你就知道自己在第几排了 .

上面的例子 , 就是一个非常标准的递归求解问题的分解过程 , 去的过程叫递 , 回来的过程叫归 . 基本上 , 所有的递归问题都可以用递推公式来表示 , 比如前面的例子 :

```
f(n) = f(n-1)+1,其中f(1) = 1
```

f\(n\)表示想知道自己在哪一排 , f\(n-1\)表示前面一排所在的排数 , f\(1\) = 1表示第一排的人知道自己在第一排 . 根据公式写代码 :

```
int f(int n) {
    if (n == 1) return 1;
    return f(n-1) + 1;
}
```

> 但是 , 对于空间性能来说 , 递归简直就是造孽 .

#### 用归纳法来理解递归

**归纳法**适用于想解决一个问题转化为解决他的子问题 , 而他的子问题又变成子问题的子问题 , 而且这些问题其实都是一个模型 , 也就是说存在相同的逻辑归纳处理项 . 当然有一个是例外的 , 也就是递归结束的那一个处理方法不适用于归纳处理项 , 当然也不能适用 , 否则就无穷递归了 . 这里又引出了一个归纳终结点以及直接求解的表达式 . 用列表来形容归纳法就是 :

* 步进表达式 : 问题蜕变成子问题的表达式
* 结束条件 : 什么时候可以不再是用步进表达式
* 直接求解表达式 : 在结束条件下能够直接计算返回值的表达式
* 逻辑归纳项 : 适用于一切非适用于结束条件的子问题的处理 , 当然上面的步进表达式其实就是包含在这里面了 . 

#### 递归代码模板

```py
def recursion(level, param1, param2, ...):
    # recursion terminator 递归终止者
    if level > MAX_LEVEL:
        print_result
        return

    # process logic in current level # 当前层级的进程逻辑(代码逻辑)
    p1_pro, p2_pro = process_data(level, data...)

    # drill down 进入下一层
    self.recursion(level + 1, p1_pro, p2_pro, ...)

    # reverse the current level status if needed
    # 如果需要的话,改变当前层的状态
    reverse_state(level)
```

#### 代码实例

计算阶乘n!

![](/assets/recursive.png)

```
n! = 1 * 2 * 3 * 4 * ... * n
```

```py
def Factorial(n):
    if n <= 1:
        return 1
    return n * Factorial(n - 1)
```

```php
function factorial($n)
{
    if ($n <= 1) {
        return 1;
    }

    return $n * factorial($n - 1);
}
```

斐波那契数列

Fibonacci array : 1 , 1 , 2 , 3 , 5 , 13 , 21 , 34 ... 

```
F(n) = F(n-1)+F(n-2)
```

```py
def fib(n):
    if n==0 or n==1:
        return n
    return fib(n-1)+fib(n-2)
```



