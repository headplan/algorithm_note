# 尾递归

尾递归Tail Recursive , 看名字就知道是某种形式的递归 . 简单的说递归就是函数自己调用自己 . 那尾递归和递归之间的差别就只能体现在参数上了 .

> 尾部递归是一种编程技巧 . 递归函数是指一些会在函数内调用自己的函数 , 如果在递归函数中 , **递归调用返回的结果总被直接返回** , 则称为尾部递归 . 尾部递归的函数有助将算法转化成函数编程语言 , 而且从编译器角度来说 , 亦容易优化成为普通循环 . 这是因为从电脑的基本面来说 , 所有的循环都是利用重复移跳到代码的开头来实现的 . 如果有尾部归递 , 就只需要叠套一个堆栈 , 因为电脑只需要将函数的参数改变再重新调用一次 . 利用尾部递归最主要的目的是要优化 , 例如在Scheme语言中 , 明确规定必须针对尾部递归作优化 . 可见尾部递归的作用 , 是非常依赖于具体实现的 .

#### 斐波那契数列的尾递归

```php
function fib($n) {
    if ($n == 1 or $n == 2) {
        return 1;
    }
    return fib($n-1)+fib($n-2);
}

function fib2($n,$a=1,$b=1)
{
    if ($n < 2) {
        return $a;
    }    
    echo '['.($n-1).']'.'['.$b.']'.'['.($a+$b).']'.PHP_EOL;
    return fib2($n-1,$b,$a+$b);
}
```

**尾递归计算过程**

```
[9][1][2]
[8][2][3]
[7][3][5]
[6][5][8]
[5][8][13]
[4][13][21]
[3][21][34]
[2][34][55]
[1][55][89]
55
```

从上面的调试就可以很清楚的看出尾递归的计算过程 . 其中$a就是第n个数 , 而$b就是第n与第n+1个数的和 , 这就是前面提到的"迭代"的精髓 , 计算结果参与到下一次的计算 , 从而减少很多重复计算量 .

fibnoacci\(n-1,acc2,acc1+acc2\)将原本的递归产生的栈的层次像二叉树一样 , 以指数级增长 , 但是现在栈的层次却像是数组 , 变成线性增长了 . 总结起来也很简单 , 原本栈是先扩展开 , 然后边收拢边计算结果 , 现在却变成在调用自身的同时通过参数来计算 .

**尾递归的本质是将单词计算的结果缓存起来 , 传递给下次调用 , 相当于自动积累 . **

在Java等命令式语言中 , 尾递归使用非常少见 , 因为可以直接用循环来解决 . 而在函数式语言中 , 尾递归却是一种神器 , 要实现循环就靠它了 . 

尾递归也是递归 , 为什么不会造成栈溢出呢 ? 因为编译器通常都会对尾递归进行优化 . 编译器会发现根本没有必要存储栈信息了 , 因而会在函数尾直接清空相关的栈 . 

