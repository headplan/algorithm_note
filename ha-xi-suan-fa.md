# 哈希算法

#### Hash

Hash一般翻译做"散列" , 也有直接音译为"哈希"的 , 就是把任意长度的输入\(又叫做预映射 , pre-image\) , 通过散列算法 , 变换成固定长度的输出 , 该输出就是散列值 .

这种转换是一种压缩映射 , 也就是散列值的空间通常远小于输入的空间 , 不同的输入可能会散列成相同的输出 , 所以不可能从散列值来唯一的确定输入值 . 简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数 .

#### 基本概念

若关键字为**k , **则其值存放在**f\(k\)**的存储位置上 . 由此 , 不需比较便可直接取得所查记录 . 称这个对应关系**f**为**散列函数** , 按这个思想建立的表为**散列表** .

对不同的关键字可能得到同一散列地址 , 即**k1≠k2** , 而**f\(k1\)=f\(k2\)** , 这种现象称为**碰撞\(Collision\)** . 具有相同函数值的关键字对该散列函数来说称做同义词 . 综上所述 , 根据散列函数**f\(k\)**和处理碰撞的方法将一组关键字映射到一个有限的连续的地址集\(区间\)上 , 并以关键字在地址集中的“像”作为记录在表中的存储位置 , 这种表便称为**散列表** , 这一映射过程称为**散列造表**或**散列** , 所得的存储位置称**散列地址** .

**散列表**\(Hash table , 也叫哈希表\) , 是根据**关键码值**\(Key value\)而直接进行访问的数据结构 . 也就是说 , 它通过把关键码值映射到表中一个位置来访问记录 , 以加快查找的速度 . 这个映射函数叫做**散列函数** , 存放记录的数组叫做**散列表** .

给定表M , 存在函数f\(key\) , 对任意给定的关键字值key , 代入函数后若能得到包含该关键字的记录在表中的地址 , 则称表M为哈希\(Hash\)表 , 函数f\(key\)为哈希\(Hash\) 函数 .

若对于关键字集合中的任一个关键字 , 经散列函数映象到地址集合中任何一个地址的概率是相等的 , 则称此类散列函数为**均匀散列函数**\(Uniform Hash function\) , 这就是使关键字经过散列函数得到一个“随机的地址” , 从而减少碰撞 .

**举个例子**

> 比如这里有一万首歌，给你一首新的歌X，要求你确认这首歌是否在那一万首歌之内。
>
> 无疑，将一万首歌一个一个比对非常慢。但如果存在一种方式，能将一万首歌的每首数据浓缩到一个数字（称为哈希码）中，于是得到一万个数字，那么用同样的算法计算新的歌X的编码，看看歌X的编码是否在之前那一万个数字中，就能知道歌X是否在那一万首歌中。
>
> 作为例子，如果要你组织那一万首歌，一个简单的哈希算法就是让歌曲所占硬盘的字节数作为哈希码。这样的话，你可以让一万首歌“按照大小排序”，然后遇到一首新的歌，只要看看新的歌的字节数是否和已有的一万首歌中的某一首的字节数相同，就知道新的歌是否在那一万首歌之内了。
>
> 当然这个简单的哈希算法很容易出现两者同样大小的歌曲，这就是发送了碰撞。而好的哈希算法发生碰撞的几率非常小。

散列表,它是基于**高速存取**的角度设计的 , 也是一种典型的"**空间换时间**"的做法 . 顾名思义 , 该数据结构能够理解为一个线性表 , 可是当中的元素不是紧密排列的 , 而是可能存在空隙 . 

散列表\(Hash table , 也叫哈希表\) , 是依据关键码值\(Key value\)而直接进行访问的数据结构 . 也就是说 , 它通过把关键码值映射到表中一个位置来访问记录 , 以加快查找的速度 . 这个**映射函数叫做散列函数 **, **存放记录的数组叫做散列表** . 

#### 特性

所有散列函数都有如下一个基本特性 : 如果两个散列值是不相同的\(根据同一函数\) , 那么这两个散列值的原始输入也是不相同的 . 这个特性是**散列函数具有确定性的结果** . 但另一方面 , **散列函数的输入和输出不是一一对应的** , 如果两个散列值相同 , 两个输入值很可能是相同的 , 但不绝对肯定二者一定相等\(可能出现哈希碰撞\) . 输入一些数据计算出散列值 , 然后部分改变输入值 , 一个具有强混淆特性的散列函数会产生一个完全不同的散列值 . 

典型的散列函数都有无限定义域 , 比如任意长度的字节字符串 , 和有限的值域 , 比如固定长度的比特串 . 在某些情况下 , 散列函数可以设计成具有相同大小的定义域和值域间的一一对应 . 一一对应的散列函数也称为排列 . 可逆性可以通过使用一系列的对于输入值的可逆"混合"运算而得到 . 

#### 哈希函数

散列函数能使对一个数据序列的访问过程更加迅速有效 , 通过散列函数 , 数据元素将被更快地定位 . 

实际工作中需视不同的情况采用不同的哈希函数 , 通常考虑的因素有 : 

* 计算哈希函数所需时间
* 关键字的长度
* 哈希表的大小
* 关键字的分布情况
* 记录的查找频率

#### **构造散列函数**

**直接定址法\(直接寻址法\)** - 取关键字或关键字的某个线性函数值为散列地址 . 即H\(key\)=key或H\(key\) = a·key + b , 其中a和b为常数\(这种散列函数叫做自身函数\) . 若其中H\(key\)中已经有值了 , 就往下一个找 , 直到H\(key\)中没有值了 , 就放进去 . 

例如：有一个从1到100岁的人口数字统计表，其中，年龄作为关键字，哈希函数取关键字自身。

**数字分析法 **- 分析一组数据 , 比如一组员工的出生年月日 , 这时我们发现出生年月日的前几位数字大体相同 , 这样的话 , 出现冲突的几率就会很大 , 但是我们发现年月日的后几位表示月份和具体日期的数字差别很大 , 如果用后面的数字来构成散列地址 , 则冲突的几率会明显降低 . 因此数字分析法就是找出数字的规律 , 尽可能利用这些数据来构造冲突几率较低的散列地址 . 

```
年.月.日
75.10.03
75.11.23
76.03.02
76.07.12
75.04.21
76.02.15
...
经分析,第一,二,三位重复的可能性大,取这三位造成冲突的机会增加,所以尽量不取前三位,取后三位比较好.
```

**平方取中法** - 当无法确定关键字中哪几位分布较均匀时 , 可以先求出关键字的平方值 , 然后按需要取平方值的中间几位作为哈希地址 . 这是因为 , 平方后中间几位和关键字中每一位都相关 , 故不同关键字会以较高的概率产生不同的哈希地址 . 

举个例子 , 我们把英文字母在字母表中的位置序号作为该英文字母的内部编码 . 例如 , K的内部编码为11 , E的内部编码为05 , Y的内部编码为25 , A的内部编码为01 , B的内部编码为02 . 由此组成关键字“KEYA”的内部代码为11052501 , 同理我们可以得到关键字"KYAB"、"AKEY"、"BKEY"的内部编码 . 之后对关键字进行平方运算后 , 取出第7到第9位作为该关键字哈希地址 , 如下表所示 : 

| 关键字 | 内部编码 | 内部编码的平方值 | H\(k\)关键字的哈希地址 |
| :--- | :--- | :--- | :--- |
| KEYA | 11050201 | 122157778355001 | 778 |
| KYAB | 11250102 | 126564795010404 | 795 |
| AKEY | 01110525 | 001233265775625 | 265 |
| BKEY | 02110525 | 004454315775625 | 315 |

  


参考 :

[https://baike.baidu.com/item/Hash/390310](https://baike.baidu.com/item/Hash/390310)

[https://baike.baidu.com/item/哈希函数/9796422](https://baike.baidu.com/item/哈希函数/9796422)

[https://www.zhihu.com/question/20820286](https://www.zhihu.com/question/20820286)

https://www.cnblogs.com/mengfanrong/p/4034950.html

https://www.cnblogs.com/alan-forever/p/3391209.html

https://www.cnblogs.com/wanghetao/p/4658471.html

