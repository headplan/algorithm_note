# 算法 - PHP实现

### 

---

### 算法的空间复杂度

#### 空间复杂度的表示

算法的空间复杂度实际上描述的就是算法程序运行时占用的内存大小 . 记作 :

```
S(n)=O(f(n))

# 其中n指的是数据规模
```

设计算法的原则中“环保性”针对的就是算法的空间复杂度 , 现在空间复杂度往往会忽略 , 因为硬件够便宜了 , 但是存在即有意义 .

时间复杂度低了那么可能就要牺牲掉空间复杂度 . 要降低空间复杂度 , 可能就要牺牲算法的时间复杂度 .

一个简单的for循环的例子 :

```
//代码片段1

$arr = [1,2,3,4,5];

for( $i=0; $i < count( $arr ); $i ++ ){
    echo $arr[ $i ];
}

//代码片段2

$arr = [1,2,3,4,5];
$len = count( $arr );

for( $i=0; $i < $len; $i ++ ){
    echo $arr[ $i ];
}
```

#### 空间复杂度的计算

实际为计算算法占用内存的大小 , 我们需要知道算法中有多少变量 , 每种变量对应了多少内存空间 . 即PHP的每种数据类型占用的实际内存的大小 .

> 由于内存空间会受到所在机器及计算机系统影响 , 这里假设是在64位下的linux系统环境下的数据

**例子1**

```
function arrIterator( $arr ){                   {1}

    for( $i=0; $i < count( $arr ); $i ++ ){     {2}
        echo $arr[ $i ];                        {3}
    }
}
```

第一步：统计算法中变量的个数，类型和对应的内存数量:

```
分析代码可知，其中用到的变量如下：
    $arr    数组    存储有n个整型元素  
    $i      整型
```

第二步：计算算法总内存空间f\(n\):

```
f(n) = n * 8 + 8 = 8*n + 8
```

第三步：计算时间复杂度T\(n\):

```
S(n) = O( f(n) ) = O( 8*n + 8 )

即

S(n) = O( 8*n + 8 )
```

第四步：简化。

```
简化方法和时间复杂度相同:

S(n) = O(n)
```

**例子2**

```
function arrIterator( $arr ){                   {1}

    $len = count( $arr );                       {2}

    for( $i=0; $i < $len; $i ++ ){              {3}
        echo $arr[ $i ];                        {4}
    }

}
```

第一步：统计算法中变量的个数，类型和对应的内存数量:

```
分析代码可知，其中用到的变量如下：
    $arr    数组    存储有n个整型元素
    $len    整型
    $i      整型
```

第二步：计算算法总内存空间f\(n\):

```
f(n) = n * 8 + 8 + 8 = 8*n + 16
```

第三步：计算时间复杂度T\(n\):

```
S(n) = O( f(n) ) = O( 8*n + 16 )

即

S(n) = O( 8*n + 16 )
```

第四步：简化。

```
S(n) = O(n)
```

通过比较两种实现方式的空间复杂度都是O\(n\)级别的，但是第二种方案使用了代码片段二优化之后反而空间复杂度比使用第一个代码片段增加了整型数据的大小，但是我们公认为第二种更快了！而其中原因就是用空间换取了时间！

> 其实算法的空间复杂度计算结果你会发现对应数据类型的空间大小都被简化没了，变成了数一数算法中变量个数的游戏！



