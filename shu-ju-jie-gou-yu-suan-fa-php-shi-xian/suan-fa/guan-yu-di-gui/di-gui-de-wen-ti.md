# 递归的问题

#### 递归代码要警惕堆栈溢出

在实际的软件开发中 , 编写递归代码时 , 会遇到很多问题 . 比如堆栈溢出 , 系统崩溃 . **为什么递归代码容易造成堆栈溢出 ? **

函数调用会使用栈来保存临时变量 . 每调用一个函数 , 都会将临时变量封装为栈帧压入内存栈 , 等待函数执行完成返回时 , 才出栈 . 系统栈或者虚拟机栈空间一般都不大 . 如果递归求解的数据规模很大 , 调用层次很深 , 一直压入栈 , 就会有堆栈溢出的风险 .

比如 , 将JVM堆栈的大小设置为1KB , 在求解f\(19999\)时 , 就会报错 :

```
Exception in thread "main" java.lang.StackOverflowError
```

**如何避免出现堆栈溢出 ? **

可以通过在代码中限制递归调用的最大深度的方式来解决这个问题 . 比如 , 设置递归调用超过一定深度之后 , 就不继续往下再递归了 , 直接返回报错 . 例如 :

```cpp
// 全局变量,表示递归的深度
int depth = 0;
int f(int n) {
    ++depth;
    if (depth > 1000) throw exception;

    if (n == 1) return 1;
    return f(n-1) + 1;
}
```

但是这种方式不能完全解决问题 , 因为最大允许的递归深度跟当前线程剩余的栈空间大小有关 , 事先无法计算 . 如果最大深度比较小 , 比如 , 10 , 50 , 就可以用这种方法 , 否则这种方法并不实用 .

#### 递归代码要警惕重复计算

前面的例子中 , 有斐波那契数列和上台阶的问题 , 如果把整个递归过程分解来看的话 , 是这样的 :

![](/assets/shangtaijie.png)

这里可以直观的看到 , 想要计算f\(5\) , 需要先计算f\(4\)和f\(3\) , 而计算f\(4\)还需要计算f\(3\) , 这里f\(3\)就被计算了很多次 , 就是重复计算问题 .

为了避免重复计算 , 可以通过一个数据结构\(比如散列表\)来保存已经求解过的f\(k\) . 当递归调用到f\(k\)时 , 先检查一下是否已经求解过了 . 如果是 , 则直接从散列表中取值返回 , 避免重复计算 . 

```java
public int f(int n) {
  if (n == 1) return 1;
  if (n == 2) return 2;
  
  // hasSolvedList 可以理解成一个 Map，key 是 n，value 是 f(n)
  if (hasSolvedList.containsKey(n)) {
    return hasSovledList.get(n);
  }
  
  int ret = f(n-1) + f(n-2);
  hasSovledList.put(n, ret);
  return ret;
}
```



