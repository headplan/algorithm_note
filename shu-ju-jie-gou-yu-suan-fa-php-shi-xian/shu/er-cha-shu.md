# 二叉树

每个节点最多有两个叉 , 也就是两个子节点 , 分别是左子节点和右子节点 . 二叉树并不要求每个节点都有两个子节点 , 有的节点只有左子节点 , 有的只有右子节点 .

![](/assets/erchashutu.png)

**满二叉树**

叶子节点全都在最底层 , 除了叶子节点之外 , 每个节点都有左右两个子节点 , 这种二叉树就叫做**满二叉树** .

**完全二叉树**

叶子节点都在最底下两层 , 最后一层的叶子节点都靠左排列 , 并且除了最后一层 , 其他层的节点个数都要达到最大 , 这种二叉树叫做**完全二叉树** .

**如何表示或者说如何存储一颗二叉树 ? **

* 基于指针或者引用的二叉链式存储法
* 基于数组的顺序存储法

**链式存储法**

每个节点有三个字段 , 其中一个存储数据 , 另外两个是指向左右子节点的指针 . 根据根节点就可以通过左右子节点把整个树串起来 . 这种存储方式比较常用 , 大部分二叉树代码都是通过这种结构来实现的 .

![](/assets/lianshicunchuerchashu.png)

**顺序存储法**

如果节点X存储在数组中下标为i的位置 , 下标为2 \* i的位置存储的就是左子节点 , 下标为2 \* i + 1的位置存储的就是右子节点 . 反之 , 下标为i / 2的位置存储的就是父节点 .

通过这种方式 , 只要知道根节点存储的位置\(为了方便计算子节点 , 根节点会存储在下标为 1 的位置\) , 就可以通过下标计算 , 串起整个树 .

![](/assets/shunxuchunchufa.png)

上面的例子是一颗完全二叉树 , 所以仅仅浪费了下标为0的存储位置 . 所以完全二叉树用数组存储最节省内存 , 其实堆就是一种完全二叉树 , 最常用的存储方式就是数组 .

再看看非完全二叉树用数组存储时候的图例 .

![](/assets/feiwanquanerchashu.png)

#### 遍历二叉树

![](/assets/bianlierchashu.png)

**前序遍历\(DLR\)** , 首先访问根结点 , 然后遍历左子树 , 最后遍历右子树 . 简记**根-左-右** . 对于树中的任意节点来说 , 先打印这个节点 , 然后再打印它的左子树 , 最后打印它的右子树

**中序遍历\(LDR\)** , 首先遍历左子树 , 然后访问根结点 , 最后遍历右子树 . 简记**左-根-右** . 对于树中的任意节点来说 , 先打印它的左子树 , 然后再打印它本身 , 最后打印它的右子树 .

**后序遍历\(LRD\) **, 首先遍历左子树 , 然后遍历右子树 , 最后访问根结点 . 简记**左-右-根 . **对于树中的任意节点来说 , 先打印它的左子树 , 然后再打印它的右子树 , 最后打印这个节点本身 .

**实际上 , 二叉树的前 , 中 , 后序遍历就是一个递归的过程 . **先看看递推公式 :

```
前序遍历的递推公式:
preOrder(r) = print r->preOrder(r->left)->preOrder(r->right)
中序遍历的递推公式:
inOrder(r) = inOrder(r->left)->print r->inOrder(r->right)
后序遍历的递推公式:
postOrder(r) = postOrder(r->left)->postOrder(r->right)->print r
```

#### 练习 : 遍历二叉树

![](/assets/lianxibinalierchashu.png)

**练习 : 推到二叉树**

已知一颗二叉树的前序遍历序列为ABCDEF , 中序遍历序列为CBAEDF , 请问这颗二叉树的后序遍历的结果是什么 ? CBEFDA

#### 二叉查找树\(Binary Search Tree\)

二叉查找树是二叉树中最常用的一种类型 , 也叫二叉搜索树 . 为了实现快速查找而生 , 当然也支持快速插入 , 删除一个数据 .

**二叉查找树要求 , 在树中的任意一个节点 , 其左子树中的每个节点的值 , 都要小于这个节点的值 , 而右子树节点的值都大于这个节点的值 . **

二叉查找树或者是一棵空树 ; 或者是具有下列性质的二叉树 :

* 1.若左子树不空 , 则左子树上所有结点的值均小于它的根结点的值; 
* 2.若右子树不空 , 则右子树上所有结点的值均大于它的根结点的值; 
* 3.左、右子树也分别为二叉排序树;

#### 红黑树



