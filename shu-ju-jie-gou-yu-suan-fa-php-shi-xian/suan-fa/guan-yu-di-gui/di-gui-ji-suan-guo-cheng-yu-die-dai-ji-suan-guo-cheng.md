# 递归计算过程与迭代计算过程

#### 递归

递归是实现程序计算过程中的描述过程的基本模式之一 , 在讨论递归的问题前需要注意 , 递归包含两个方面的内容 , 一个是递归的计算过程 , 一个递归过程 . 后者是语法上的事实 , 而前者是概念上的计算过程 , 事实上在程序上我们也许是使用循环来实现 .

递归计算过程和递归过程不是一回事 .

**递归过程**

当我们说一个过程是递归的时候 , 论述的是一个语法形式上的事实 , 说明这个过程的定义中\(直接或者间接地\)引用了该过程本身 .

**递归计算过程**

在说某一计算过程具有某种模式时\(例如 , 线性递归\) , 说的是这一计算过程的进展方式 , 而不是相应过程书写上的语法形式 .

![](/assets/fibonacci.png)

上图是斐波那契数列的递归过程 , 如同一颗倒置的树 , 这种方式被称为**树形递归** , 也被称为**线性递归** . 这种递归的方式非常直白 , 很好理解其计算过程 , 一般很多人写递归都会下意识的采用这种方式 . 但是缺点也是很明显的 , 从其计算过程可以看出 , 经过了很多冗余的计算 , 并且消耗了大量的调用堆栈 , 这个消耗是指数级增长的 , 经常有人说调用堆栈很容易在很短的递归过程就耗光了 , 多半就是采用了线性递归造成的 . 线性递归的过程可用下图描述 , 可以清晰的看到展开收拢的过程 :

```php
(factorial (6))
(6 * factorial (5))
(6 * (5 *  factorial (4)))
(6 * (5 * (4 * factorial (3))))
(6 * (5 * (4 * (3 * factorial (2)))))
(6 * (5 * (4 * (3 * (2 * factorial (1))))))
(6 * (5 * (4 * (3 * (2 * 1)))))
(6 * (5 * (4 * (3 * 2))))
(6 * (5 * (4 * 6)))
(6 * (5 * 24))
(6 * 120)
720
```

#### 迭代

与迭代计算过程相对应的是迭代计算过程 .

除了上面提到的递归方式 , 还有另外一种实现递归的方式 , 同样是上面的斐波那契数列作为例子 , 这次我们不暗号斐波那契的定义入手 , 而是从正常产生数列的过程入手来实现 .

0 , 1的情况很简单可以直接返回 , 之后的计算过程就是累加 ,  在递归的过程中要保持状态 , 这个状态要保持三个数 , 也就是上两个数和迭代的步数 , 所以定义的方法为 :

```php
function fib4($n, $b1 = 1, $b2 = 2, $c = 3) {
    if ($n == 1 or $n == 2) {
        return $n;
    } else {
        if ($n == $c) {
            return $b1 + $b2;
        } else {
            $ret = $b1+$b2;
            $b1 = $b2;
            $b2 = $ret;
            $c = ($c+1);
            return fib4($n,$b1,$b2,$c);
        }
    }
}
```

这种方法在每一次递归的过程中保持了上一次计算的状态 , 所以称之为"线性迭代过程" , 也就是俗称的**尾递归** . 由于每一步计算都保持了状态 , 所以消除了冗余计算 , 所以这种方式的效率明显高于前面的普通递归 , 计算过程如下 :

```php
fib(6)
fib  0,1,2
fib  1,2,3
fib  2,3,4
fib  3,5,5
fib  5,8,6
```

**这两种递归方式之间是可以转换的 , 凡是可以通过固定数量状态来描述中间计算过程的递归过程 , 都可以通过线性迭代来表示 . **

迭代计算过程是用固定数目的状态变量描述的计算过程 , 并存在着一套固定的规则 , 描述了计算过程从一个状态到下一状态转换时 , 这些变量的更新方式 , 还有一个结束检测 , 它描述这一计算过程应该终止的条件 . 

以计算n的阶乘为例 , 其递归写为 : 

```php
function n($n) {
	if ($n == 1) {
		return $n;
	}
	
	return $n * n($n-1);
}
```



