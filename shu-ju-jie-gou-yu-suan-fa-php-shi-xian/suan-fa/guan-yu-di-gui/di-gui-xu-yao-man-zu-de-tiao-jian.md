# 递归需要满足的条件

#### 递归需要满足的三个条件

1. 一个问题的解可以分解为几个子问题的解
2. 这个问题与分解之后的子问题 , 除了数据规模不同\(更小\) , 求解思路完全一样
3. 存在递归终止条件

很多人对递归的理解不太深刻 . 一直就停留在"自己调用自己"的程度上 . 递归并不是简单的自己调用自己 , 也不是简单的交互调用 . 它是一种分析和解决问题的方法和思想 . 简单的说 , **就是把问题分解成规模更小 , 具有与原问题相同的解法的问题** . 比如二分查找 , 也是把问题规模不断变小 , 新问题和原问题的解法相同 .

有些问题使用传统的迭代算法是很难求解甚至无解的 , 而使用递归却可以很容易的解决 . 比如汉诺塔问题 . 但递归的使用也是有它的劣势的 , 因为它要进行多层函数调用 , 所以会消耗很多堆栈空间和函数调用时间 .

#### 求斐波那契数列的第N项的值

Fibonacci array : 1 , 1 , 2 , 3 , 5 , 13 , 21 , 34 ...

```
f(0) = 0
f(1) = 1
f(n) = f(n-1) + f(n-2)
```

![](/assets/fibonacci.png)

1. 很显然 , 上面的问题可以分解为多个子问题 . 
2. 对于一个n&gt;2 , 求f\(n\)只需求出f\(n-1\)和f\(n-2\) , 也就是说规模为n的问题 , 转化成了规模更小的问题 ; 
3. 对于n=0和n=1 , 存在着简单情境 : f\(0\) = 0 , f\(1\) = 1让递归终止 ; 

```py
def fib(n):
    if n == 0 or n == 1:
        return n
    return fib(n - 1) + fib(n - 2)
```

```php
function fib($n)
{
    if ($n == 0 or $n == 1) {
        return $n;
    }
    return fib($n - 1) + fib($n - 2);
}
```

如果有n个台阶 , 每次可以跨1个台阶或者2个台阶 , 请问走这n个台阶有多少种走法 ? 比如有 7 个台阶 , 可以2 , 2 , 2 , 1这样上去 , 也可以1 , 2 , 1 , 1 , 2上去 , 总之走法很多 , 如何用编程求得总共有多少种走法呢 ?

```
f(1) = 1;
f(2) = 2;
f(n) = f(n-1)+f(n-2)
```

```cpp
int f(int n) {
  if (n == 1) return 1;
  if (n == 2) return 2;
  return f(n-1) + f(n-2);
}
```



