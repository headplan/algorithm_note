# 复杂度分析

**算法**\(algorithms\) - 是针对特定的问题 , 经过精心设计的用来一步步解决该问题从而得到答案的过程 .

直观简单的例子 , 把大象装冰箱的过程 , 就是一个简答算法 . 更真实的例子 , 100条有序的记录 , 普通的算法是从头一条一条的比对 , 直到找到为止 , 用二分查找 , 找7次就找到了 .

算法和数据结构的关系 , 可以抽象的理解为米与巧妇的关系 .

#### 算法具有五个基本特性

输入、输出、有穷性、确定性和可行性 .

**输入输出 - **算法允许具有零个或多个输入,但是必须至少有一个或多个输出 .

**有穷性** - 有穷性是指算法在执行有限的步骤之后 , 可以自动结束而不会出现无限循环 , 并且每一个步骤的执行时间都在可接受的范围内

**确定性** - 算法的每一步骤都具有确定的含义 , 不会出现二义性 .

**可行性** - 再现有的条件下算法的每一个步骤都应该是可以实现的 .

#### 算法设计和实现的原则

正确性、健壮性、高效性、环保性和可读性！

---

如何判断我们的算法效率高?

> 什么是时间复杂度?如何计算时间复杂度?
>
> 二分法的时间复杂度是多少?暴力破解不重复的6位密码时间复杂度是多少?

* 算法分析方法论
* 算法的时间复杂度
* 常见的时间复杂度类型
* 时间复杂度知识扩展
* 算法的空间复杂度

#### 算法分析方法论

##### 事后统计方案

为什么需要时间复杂度 ? 通常 , 通过统计 , 监控 , 就能得到算法执行的时间和占用的内存大小 . 为什么还需要做时间 , 空间复杂度的分析呢 ? 虽然这种评估算法执行效率的方法是正确的 , 也叫做事后统计法 . 但是 , 这种统计方法有非常大的局限性 .

1.测试结果非常依赖测试环境

测试环境中硬件的不同会对测试结果有很大的影响 . 比如在不同的处理器上 , 代码的执行的效率就是不同的 .

2.测试结果受数据规模的影响很大

比如同一个排序算法 , 测试数据的规模直接影响算法的性能 . 对于小规模的数据排序 , 插入排序可能反倒会比快速排序要快 .

所以 , 我们需要一个不用具体的测试数据来测试 , 就可以粗略的估计算法的执行效率的方法 . 可以称之为事前评估方案 .

##### 事前评估方案

方法论就是 - 时间复杂度和空间复杂度 .

---

### 算法的时间复杂度

算法的时间复杂度实际上就是算法的运行花费的时间 . 但是并不代表代码真正的执行时间 , 而是表示**代码执行时间随数据规模增长的变化趋势** , 所以也叫渐进时间复杂度 , 简称时间复杂度 .

所有代码的执行时间T\(n\)与每行代码的执行次数n成正比 ,

用固定的公式来**表示时间复杂度** :

```
T(n) = O(f(n))
```

其中`n`表示的是数据规模 , `f(n)`是算法执行的总时间 . 计算时间复杂度 :

```
f(n) = 算法执行语句的数量 * t
```

即算法中语句的执行数量与单条语句执行时间`t`的积 . 所以这样看更明显 :

```
T(n) = O(算法运行总时间)
```

这种 , 把算法运行总时间放在了一个固定的格式中的表示方式叫大O表示法 , 表示**最坏复杂度** , 也就是最差也就这样了 . 对应的还有**最好的大Ω表示法**和**平均的大Θ表示法** .

> 公式中的低阶 , 常量 , 系数三部分并不左右增长趋势 , 所以都可以忽略 .

#### 时间复杂度计算实例

```
计算 1+2+3+4+5.....+n 的和！
```

**第一种方式**

生成一个长度为n的数组 , 然后把数据存储到数组中 , 再计算数组各项的和 :

```php
<?php

function sum($n)
{
    $result = 0; # {1}
    $array = range(1, $n); # {2}

    for ($i=0; $i < $n; $i++) { # {3}
        $result += $array[$i]; # {4}
    }

    return $result; # {5}
}
```

计算时间复杂度的流程 , 先看函数体内代码运行过程中执行的次数 . 其中注释的1,2,5都仅执行了一次 , 而3,4步骤执行次数为n . 转换为公式即 :

```
N = 2*n+3 # 计算结构就是算法执行语句的数量
```

套入算法总运行时间公式就是 :

```
f(n) = N * t = (2*n + 3) * t
```

最后表示为时间复杂度 , 即 :

```
T(n) = O((2*n + 3) * t)
```

继续简化 , 这里的t代表的是每一条语句的运行时间 , 因为他们是相同的 , 是一个常数不影响分析结果 :

```
T(n) = O(2*n + 3)
```

用常数1取代运行时间中的所有加法常数 :

```
T(n) = O(2*n + 1)
```

如果最高阶项存在且不是1 , 则去除与这个项相乘的常数 :

```
T(n) = O( n + 1 )
```

如果存在数据规模n , 去掉加法常数项 :

```
T(n) = O(n)
```

**第二种方式**

这里简单修改一下上面的函数 , 不生成数组 , 直接循环计算 :

```php
<?php

function sum($n)
{
    $result = 0;

    for ($i=1; $i <= $n; $i++) {
        $result += $i;
    }

    return $result;
}
```

通过前面的计算 , 最后得到的算法时间复杂度是相同的 . 可以理解为时间复杂度描述的实际上是一种“级别” , 就像手机一样 , 有千元机和旗舰机等 . **同一算法时间复杂度级别中的算法的效率不会差异非常大 .**

**第三种方式**

```
利用高斯公式:f(n) = (1+n)*n/2
```

```php
<?php

function sum($n){
    $result = 0;                               
    $result = (1 + $n) * $n / 2;                 

    return $result;                            
}
```

可以直接看出这里的N=3 , 通过计算 , 时间复杂度为 :

```
T(n) = O(1)
```

这是时间复杂度级别是最好的级别 , 随着数据规模的增加 , O\(n\)级别的算法和O\(1\)级别的算法的差距越来越大 , 说明了时间复杂度描述的是算法动态渐变的状态 .

**只关注循环执行次数最多的一段代码**

在分析一个算法 , 一段代码的时间复杂度的时候 , 也只关注循环执行次数最多的那一段代码就可以了 , 这段核心代码执行次数的n的量级 , 就是整段要分析代码的时间复杂度 .

**加法法则 : 总复杂度等于量级最大的那段代码的复杂度**

**乘法法则 : 嵌套代码的复杂度等于嵌套内外代码复杂度的乘积**

#### 常见的时间复杂度

![](/assets/changjianfuzadu.png)

常量阶 O\(1\)

对数阶 O\(logn\)

线性阶 O\(n\)

线性对数阶 O\(nlogn\)

平方阶 O\(n^2\)

立方阶 O\(n^3\)

指数阶 O\(2^n\)

阶乘阶 O\(n!\)

k次方阶 O\(n^k\)

```
O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^k)
```

上面罗列的复杂度量级可以粗略的分为两类 :

**多项式量级**和**非多项式量级** . 其中非多项式量级只有两个O\(2^n\)和O\(n!\) .

当数据规模n越来越大时 , 非多项式量级算法的执行时间急剧增加 , 求解问题的执行时间会无限增长 . 所以 , 非多项式时间复杂度的算法其实是非常低效的算法 .

**O\(1\)复杂度**

O\(1\)只是常量级时间复杂度的一种表示方法 , 并不是指只执行一行代码 . 只要代码的执行时间随n的增大而增大 , 这样的代码的时间复杂度都记作O\(1\) .

**一般情况下 , 只要算法中不存在循环语句 , 递归语句 , 即使有成千上万行的代码 , 其时间复杂度也是O\(1\) .**

**O\(logn\) , O\(nlogn\)复杂度**

对数阶时间复杂度非常常见 , 同时也是最难分析的一种时间复杂度 . 例如 :

```
i=1;
while (i <= n) {
    i = i * 2;
}
```

这里的变量i的取值就是一个等比数列 . 2^x=n , 求解x . x=log2n , 所以代码的时间复杂度就是O\(log2n\) .

实际上 , 不管是以2为底 , 还是以3为底 , 还以10为底 , 我们可以把所有对数阶的时间复杂度都记为O\(logn\) , 根据对数之间的转换公式 , 可以得到log3n=log32\*log2n , 可以得到O\(C\*log3n\)=O\(C\*log2n\) , 其中C=log32是一个常量 . 因为 ,

采用大O标记复杂度的时候 , 可以忽略系数 , 即O\(Cf\(n\)\)=O\(f\(n\)\) . 因此对数阶时间复杂度的表示方法里 , 可以忽略对数的底 , 统一表示为O\(logn\) .

对于O\(nlogn\)时间复杂度 , 根据乘法法则 , 如果一段代码的时间复杂度是O\(logn\) , 循环执行n遍 , 时间复杂度就是O\(nlogn\)了 . 而且 , O\(nlogn\)也是一种非常常见的算法时间复杂度 , 比如 , 并归排序 , 快速排序的时间复杂度都是O\(nlogn\) .

**O\(m+n\) , O\(m\*n\)**

这种代码的时间复杂度是由两个数据的规模来决定 . 例如

```
int cal(int m, int n) {
    int sum_1 = 0;
    int i = 1;
    for (; i < m; ++i) {
        sum_1 = sum_1 + i;
    }

    int sum_2 = 0;
    int j = 1;
    for (; j < n; ++j) {
        sum_2 = sum_2 + j;
    }

    return sum_1 + sum_2;
}
```

m和n表示两个数据规模 , 无法事先评估谁的量级大 , 不能省略掉一个 , 所以复杂度为O\(m+n\) .

#### 空间复杂度的表示

算法的空间复杂度实际上描述的就是算法程序运行时占用的内存大小 . 记作 :

```
S(n)=O(f(n))

# 其中n指的是数据规模
```

设计算法的原则中“环保性”针对的就是算法的空间复杂度 , 现在空间复杂度往往会忽略 , 因为硬件够便宜了 , 但是存在即有意义 .

时间复杂度低了那么可能就要牺牲掉空间复杂度 . 要降低空间复杂度 , 可能就要牺牲算法的时间复杂度 .

一个简单的for循环的例子 :

```
//代码片段1

$arr = [1,2,3,4,5];

for( $i=0; $i < count( $arr ); $i ++ ){
    echo $arr[ $i ];
}

//代码片段2

$arr = [1,2,3,4,5];
$len = count( $arr );

for( $i=0; $i < $len; $i ++ ){
    echo $arr[ $i ];
}
```

---

#### 空间复杂度的计算

空间复杂度全称就是**渐进空间复杂度** , **表示算法的存储空间与数据规模之间的增长关系 . **

常见的空间复杂度就是O\(1\) , O\(n\) , O\(n^2\) , 像O\(logn\) , O\(nlogn\)这样的对数阶复杂度平时都用不到 . 存储一个二进制数 , 输入规模\(空间复杂度\)是O\(logn\)bit . 比如8用二进制表示就是3个bit . 16用二进制表示就是4个bit . 以此类推 n用二进制表示就是logn个bit . 简单的就足够了 .

实际为计算算法占用内存的大小 , 我们需要知道算法中有多少变量 , 每种变量对应了多少内存空间 . 即PHP的每种数据类型占用的实际内存的大小 .

> 由于内存空间会受到所在机器及计算机系统影响 , 这里假设是在64位下的linux系统环境下的数据

**例子1**

```
function arrIterator( $arr ){                   {1}

    for( $i=0; $i < count( $arr ); $i ++ ){     {2}
        echo $arr[ $i ];                        {3}
    }
}
```

第一步：统计算法中变量的个数，类型和对应的内存数量:

```
分析代码可知，其中用到的变量如下：
    $arr    数组    存储有n个整型元素  
    $i      整型
```

第二步：计算算法总内存空间f\(n\):

```
f(n) = n * 8 + 8 = 8*n + 8
```

第三步：计算时间复杂度T\(n\):

```
S(n) = O( f(n) ) = O( 8*n + 8 )

即

S(n) = O( 8*n + 8 )
```

第四步：简化。

```
简化方法和时间复杂度相同:

S(n) = O(n)
```

**例子2**

```
function arrIterator( $arr ){                   {1}

    $len = count( $arr );                       {2}

    for( $i=0; $i < $len; $i ++ ){              {3}
        echo $arr[ $i ];                        {4}
    }

}
```

第一步：统计算法中变量的个数，类型和对应的内存数量:

```
分析代码可知，其中用到的变量如下：
    $arr    数组    存储有n个整型元素
    $len    整型
    $i      整型
```

第二步：计算算法总内存空间f\(n\):

```
f(n) = n * 8 + 8 + 8 = 8*n + 16
```

第三步：计算时间复杂度T\(n\):

```
S(n) = O( f(n) ) = O( 8*n + 16 )

即

S(n) = O( 8*n + 16 )
```

第四步：简化。

```
S(n) = O(n)
```

通过比较两种实现方式的空间复杂度都是O\(n\)级别的，但是第二种方案使用了代码片段二优化之后反而空间复杂度比使用第一个代码片段增加了整型数据的大小，但是我们公认为第二种更快了！而其中原因就是用空间换取了时间！

> 其实算法的空间复杂度计算结果你会发现对应数据类型的空间大小都被简化没了，变成了数一数算法中变量个数的游戏！



