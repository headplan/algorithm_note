# 递归计算过程与迭代计算过程

#### 递归

递归是实现程序计算过程中的描述过程的基本模式之一 , 在讨论递归的问题前需要注意 , 递归包含两个方面的内容 , 一个是递归的计算过程 , 一个递归过程 . 后者是语法上的事实 , 而前者是概念上的计算过程 , 事实上在程序上我们也许是使用循环来实现 .

递归计算过程和递归过程不是一回事 .

**递归过程**

当我们说一个过程是递归的时候 , 论述的是一个语法形式上的事实 , 说明这个过程的定义中\(直接或者间接地\)引用了该过程本身 .

**递归计算过程**

在说某一计算过程具有某种模式时\(例如 , 线性递归\) , 说的是这一计算过程的进展方式 , 而不是相应过程书写上的语法形式 .

![](/assets/fibonacci.png)

上图是斐波那契数列的递归过程 , 如同一颗倒置的树 , 这种方式被称为**树形递归** , 也被称为**线性递归** . 这种递归的方式非常直白 , 很好理解其计算过程 , 一般很多人写递归都会下意识的采用这种方式 . 但是缺点也是很明显的 , 从其计算过程可以看出 , 经过了很多冗余的计算 , 并且消耗了大量的调用堆栈 , 这个消耗是指数级增长的 , 经常有人说调用堆栈很容易在很短的递归过程就耗光了 , 多半就是采用了线性递归造成的 . 线性递归的过程可用下图描述 , 可以清晰的看到展开收拢的过程 :

```php
(factorial (6))
(6 * factorial (5))
(6 * (5 *  factorial (4)))
(6 * (5 * (4 * factorial (3))))
(6 * (5 * (4 * (3 * factorial (2)))))
(6 * (5 * (4 * (3 * (2 * factorial (1))))))
(6 * (5 * (4 * (3 * (2 * 1)))))
(6 * (5 * (4 * (3 * 2))))
(6 * (5 * (4 * 6)))
(6 * (5 * 24))
(6 * 120)
720
```

#### 迭代

与迭代计算过程相对应的是迭代计算过程 .

除了上面提到的递归方式 , 还有另外一种实现递归的方式 , 同样是上面的斐波那契数列作为例子 , 这次我们不暗号斐波那契的定义入手 , 而是从正常产生数列的过程入手来实现 .

0 , 1的情况很简单可以直接返回 , 之后的计算过程就是累加 ,  在递归的过程中要保持状态 , 这个状态要保持三个数 , 也就是上两个数和迭代的步数 , 所以定义的方法为 :

```php
function fib4($n, $b1 = 1, $b2 = 2, $c = 3) {
    if ($n == 1 or $n == 2) {
        return $n;
    } else {
        if ($n == $c) {
            return $b1 + $b2;
        } else {
            $ret = $b1+$b2;
            $b1 = $b2;
            $b2 = $ret;
            $c = ($c+1);
            return fib4($n,$b1,$b2,$c);
        }
    }
}
```

这种方法在每一次递归的过程中保持了上一次计算的状态 , 所以称之为"线性迭代过程" , 也就是俗称的**尾递归** . 由于每一步计算都保持了状态 , 所以消除了冗余计算 , 所以这种方式的效率明显高于前面的普通递归 , 计算过程如下 :

```php
fib(6)
fib  0,1,2
fib  1,2,3
fib  2,3,4
fib  3,5,5
fib  5,8,6
```

**这两种递归方式之间是可以转换的 , 凡是可以通过固定数量状态来描述中间计算过程的递归过程 , 都可以通过线性迭代来表示 . **

迭代计算过程是用固定数目的状态变量描述的计算过程 , 并存在着一套固定的规则 , 描述了计算过程从一个状态到下一状态转换时 , 这些变量的更新方式 , 还有一个结束检测 , 它描述这一计算过程应该终止的条件 .

以计算n的阶乘为例 , 其递归写为 :

```php
function n($n) {
    if ($n == 1) {
        return $n;
    }

    return $n * n($n-1);
}
```

同样是阶乘 , 可以写为 :

```php
function n2($n, $res=1, $counter=2) {
    if ($counter > $n) {
        return $res;
    }
    return n2($n,$res*$counter,$counter+1);
}
```

虽然n2方法调用了它自己 , 但从它的执行过程里 , 所需要的所有的东西都是`$n,$res,$counter`. 所以它是迭代计算过程 . 这个过程在继续调用自身时 , 不需要增加存储 , 这个的过程就叫**尾递归** .

尾递归还可以用循环来代替 :

```php
function n3($n) {
    $a=1;$b=2;
    for ($i=2;$i<=$n;$i++) {
        $c = $a*$b;
        $a = $c;
        $b = $b+1;
    }
    return $a;
}
```

不难看出 , 有时候说要减少递归 , 就是要减少递归计算过程 , 用更高效的方法代替 . 其实尾递归的过程和循环基本上是等价的 . 我们可以将尾递归的过程很方便到用循环来代替 , 所以很多的语言对尾递归提供了编译级别的优化 , 也就是将尾递归在编译期转化成循环的代码 . 

> 不过对于没有提供尾递归优化的语言来说也是很有意义的 , 比如Python的默认调用堆栈长度是1000 , 如果用线性递归很快就会消耗光 , 但是尾递归就不会 , 比如尾递归的Fib函数 , 用Fib\(1001\)调用没问题的而且跑得飞快 , Fib\(1002\)的时候才堆栈溢出 . 但是如果是线性递归的方式计算n=30的时候就能明显感觉到速度变慢 , 40以上基本就挂了 .



